<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Flipbook — CAPMEX</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg:#111; --panel:#1b1b1b; --txt:#eee; --muted:#aaa;
      --toolbar-h:64px; --maxw:1400px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; background:var(--bg); color:var(--txt);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      padding-top:var(--toolbar-h);
    }
    .toolbar{
      position:fixed; inset:0 0 auto 0; z-index:9;
       z-index: 10000;
      display:flex; gap:8px; align-items:center; flex-wrap:wrap;
      background:var(--panel); padding:10px 16px; box-shadow:0 8px 24px rgba(0,0,0,.35);
    }
    .btn{border:0; border-radius:8px; padding:8px 12px; background:#2a2a2a; color:var(--txt); cursor:pointer}
    .btn:hover{background:#333}
    .status{margin-left:auto; color:var(--muted); font-size:14px
    }

    #stage{
      height:calc(100vh - var(--toolbar-h));
      display:flex; justify-content:center; align-items:center;
      width:100%; max-width:var(--maxw); margin:0 auto; padding:0 12px;
      touch-action: pan-y; /* permitir scroll vertical, bloquear pan-x (ya volteamos con tap/drag) */
    }
    #flipbook{background:#222; box-shadow:0 10px 30px rgba(0,0,0,.5)}
    .page{background:#212121; overflow:hidden; user-select:none; -webkit-user-select:none; touch-action:none;}
    .page img{width:100%; height:100%; display:block; object-fit:contain; object-position:center; pointer-events:none;}

    /* Desktop: una hoja (sheet) contiene 2 imágenes (izq/der) */
    .sheet{ display:flex; width:100%; height:100%; }
    .sheet > img{ width:50%; height:100%; object-fit:contain; object-position:center; }

    /* Móvil: cada mitad ocupa página completa */
    .page-half img{ width:100%; height:100%; object-fit:contain; object-position:center; }

    #loader{text-align:center; color:var(--muted); padding:14px}
    .hidden{display:none!important}
  </style>
</head>
<body>
  <!-- Barra -->
  <div class="toolbar" id="toolbar">
    <button id="prev"   class="btn" type="button">⟵ Anterior</button>
    <button id="next"   class="btn" type="button">Siguiente ⟶</button>
    <button id="first"  class="btn" type="button">⟪ Primera</button>
    <button id="last"   class="btn" type="button">Última ⟫</button>
    <span id="pageInfo" class="status">Cargando…</span>
  </div>

  <div id="loader">Preparando visor…</div>

  <main id="stage">
    <div id="flipbook"></div>
  </main>

  <!-- Librerías -->
  <script src="assets/revistas/portadas/libs/jquery/jquery.min.js"></script>
  <script src="assets/revistas/portadas/libs/turnjs/turn.min.js"></script>
  <script src="assets/revistas/portadas/libs/pdfjs/pdf.min.js"></script>
  <script>
    if (window.pdfjsLib) {
      pdfjsLib.GlobalWorkerOptions.workerSrc = "assets/revistas/portadas/libs/pdfjs/pdf.worker.min.js";
    }
  </script>

  <script>
  // ==========================
  //  AJUSTES RÁPIDOS (PERILLAS)
  // ==========================
  // Calidad/nitidez de render:
  const SCALE_INNER       = 1.60;   // interiores
  const SCALE_COVER       = 1.40;   // portada/contraportada
  // Tamaño mínimo visible para que no quede ilegible:
  const DESKTOP_MIN_SCALE = 0.62;
  const MOBILE_MIN_SCALE  = 0.86;
  // Umbrales de layout:
  const BREAKPOINT_NARROW = 900;    // < 900 = móvil
  const SPREAD_THRESHOLD  = 1.20;   // (w/h) > 1.20 => spread (doble)

  // =============== Parámetros URL ===============
  const params   = new URLSearchParams(location.search);
  let   PDF_URL  = params.get('doc')   || "";
  const TITLE    = params.get('title') || "Revista CAPMEX";

  if (PDF_URL && !/^https?:\/\//i.test(PDF_URL) && !PDF_URL.startsWith('assets/')) {
    PDF_URL = 'assets/revistas/' + PDF_URL.replace(/^\/+/, '');
  }
  if (!/^https?:\/\/|^assets\/revistas\//i.test(PDF_URL)) PDF_URL = "";

  try { document.title = `${TITLE} — Flipbook`; } catch {}

  // =============== Refs UI ===============
  const $toolbar = $("#toolbar"), $stage = $("#stage"), $loader = $("#loader");
  const $pageInfo = $("#pageInfo");
  let $flip = $("#flipbook"); // ¡OJO!: let, porque lo re-asignamos cuando reconstruimos

  // =============== Estado ===============
  let spreads = [];  // [{type:'single', src,w,h} | {type:'spread', left:{src,w,h}, right:{src,w,h}, w,h}]
  let total   = 0;
  let canonicalDesktopW=0, canonicalDesktopH=0; // hoja completa
  let canonicalMobileW =0, canonicalMobileH =0; // media hoja
  let pageW0=0, pageH0=0;

  const isMobile = () => window.innerWidth < BREAKPOINT_NARROW;

  function syncToolbarHeight(){
    const h = Math.ceil($toolbar.outerHeight() || 64);
    document.documentElement.style.setProperty('--toolbar-h', h + 'px');
  }

  // ==== Helpers gráficos ====
  function splitCanvas(c){
    const w=c.width, h=c.height, mid=Math.floor(w/2);
    const l=document.createElement('canvas'), r=document.createElement('canvas');
    l.width=mid; l.height=h; r.width=w-mid; r.height=h;
    l.getContext('2d').drawImage(c, 0,   0, mid,   h, 0, 0, mid,   h);
    r.getContext('2d').drawImage(c, mid, 0, w-mid, h, 0, 0, w-mid, h);
    return {
      left:  {src: l.toDataURL('image/jpeg',0.9), w:l.width, h:l.height},
      right: {src: r.toDataURL('image/jpeg',0.9), w:r.width, h:r.height}
    };
  }

  // Tamaño visible calculado desde canónicos (NO “baila” en resize)
  function computeSize(){
    const stageW = Math.min($stage.innerWidth(), window.innerWidth - 24);
    const toolbarH = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--toolbar-h')) || 64;
    const stageH = Math.max(260, window.innerHeight - toolbarH);

    const baseW = isMobile() ? canonicalMobileW : canonicalDesktopW;
    const baseH = isMobile() ? canonicalMobileH : canonicalDesktopH;

    const scaleW = stageW / baseW;
    const scaleH = stageH / baseH;
    const min = isMobile() ? MOBILE_MIN_SCALE : DESKTOP_MIN_SCALE;
    const scale = Math.max(min, Math.min(scaleW, scaleH));

    return { width: Math.floor(baseW*scale), height: Math.floor(baseH*scale) };
  }

  function applyLayout(force=false){
    const s = computeSize();
    if (!s.width || !s.height) return;
    if ($flip.data('turn')) {
      $flip.turn('display','single');
      $flip.turn('size', s.width, s.height);
      $flip.turn('center');
      if (force) $flip.turn('update');
    } else {
      $flip.css({width:s.width+'px', height:s.height+'px'});
    }
  }

function bindUI(){
  // Botones
  $("#prev").on("click", () => $flip.turn("previous"));
  $("#next").on("click", () => $flip.turn("next"));
  $("#first").on("click", () => $flip.turn("page", 1));
  $("#last").on("click", () => $flip.turn("page", total));

  // ---- TAP lateral con Pointer Events (mouse/pen/touch unificados) ----
  const el = document.getElementById('stage');

  let downX = 0, downY = 0, isDragging = false;
  let lastFlipTs = 0;                  // anti-doble click
  const DRAG_TOL = 12;                 // px
  const COOLDOWN = 260;                // ms

  function onPointerDown(ev){
    // Solo dentro del stage
    const r = el.getBoundingClientRect();
    if (ev.clientX < r.left || ev.clientX > r.right || ev.clientY < r.top || ev.clientY > r.bottom) return;

    isDragging = false;
    downX = ev.clientX;
    downY = ev.clientY;

    // evitamos que el toque se traduzca luego en click/mouseup sintético
    ev.preventDefault();
    ev.stopPropagation();

    // capturamos el puntero para recibir el pointerup aunque salga del elemento
    if (el.setPointerCapture && ev.pointerId != null) {
      try { el.setPointerCapture(ev.pointerId); } catch {}
    }
  }

  function onPointerMove(ev){
    if (!downX && !downY) return;
    const dx = ev.clientX - downX;
    const dy = ev.clientY - downY;
    if (Math.hypot(dx, dy) > DRAG_TOL) isDragging = true;
  }

  function onPointerUp(ev){
    // liberar captura si procede
    if (el.releasePointerCapture && ev.pointerId != null) {
      try { el.releasePointerCapture(ev.pointerId); } catch {}
    }

    // Cancelar si fue un arrastre
    if (isDragging) { downX = downY = 0; return; }

    // Anti-doble firing (ej. sistemas ruidosos)
    const now = Date.now();
    if (now - lastFlipTs < COOLDOWN) { downX = downY = 0; return; }
    lastFlipTs = now;

    // ¿toca izquierda o derecha?
    const rect = el.getBoundingClientRect();
    const x = ev.clientX - rect.left;
    if (x < rect.width * 0.35) $flip.turn("previous");
    else $flip.turn("next");

    ev.preventDefault();
    ev.stopPropagation();

    downX = downY = 0;
  }

  // Importante: usamos pointer events sólo una vez (sin duplicar mouse/touch)
  el.addEventListener('pointerdown', onPointerDown, {passive:false});
  el.addEventListener('pointermove', onPointerMove, {passive:true});
  el.addEventListener('pointerup',   onPointerUp,   {passive:false});

  // Re-montar si cambia de móvil↔escritorio; si no, sólo reajustar
  $(window).on("resize orientationchange", ()=>{
    const wasMobile = $flip.data('__isMobile');
    const nowMobile = isMobile();
    if (wasMobile !== nowMobile) { mountFlip(); return; }
    syncToolbarHeight();
    applyLayout(true);
  });
}

  // --- Scroll para pasar página (rueda del mouse / trackpad) ---
  function bindWheelPaging() {
    const el = document.getElementById('stage');
    if (!el) return;

    let accum = 0;                  // acumula deltas pequeños (trackpad)
    const THRESH = 120;             // umbral típico de una “muesca” de rueda
    let lastFlip = 0;
    const COOLDOWN = 220;           // ms entre flips para no disparar varios

    function handler(ev) {
      if (!$flip.data('turn')) return;

      // solo si el cursor está sobre el visor
      const rect = el.getBoundingClientRect();
      const x = ev.clientX, y = ev.clientY;
      if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) return;

      const dx = ev.deltaX || 0;
      const dy = ev.deltaY || 0;
      const mainDelta = Math.abs(dx) > Math.abs(dy) ? dx : dy;

      accum += mainDelta;

      const now = Date.now();
      if (Math.abs(accum) >= THRESH && (now - lastFlip) >= COOLDOWN) {
        if (accum > 0) $flip.turn('next'); else $flip.turn('previous');
        lastFlip = now;
        accum = 0;
        ev.preventDefault();
      }
    }

    el.addEventListener('wheel', handler, { passive: false });
  }

  function mountFlip(){
    // destruir (si existía) y recrear contenedor
    if ($flip && $flip.data('turn')) { try { $flip.turn('destroy'); } catch{} }
    $("#flipbook").replaceWith('<div id="flipbook"></div>');
    $flip = $("#flipbook");

    $flip.empty();
    total = 0;
    const mobile = isMobile();
    $flip.data('__isMobile', mobile);

    if (mobile){
      // MÓVIL: cada spread -> dos páginas; single -> una página
      spreads.forEach(pg=>{
        if (pg.type==='spread'){
          $flip.append($('<div class="page page-half"><img/></div>').find('img').attr('src', pg.left.src).end());
          $flip.append($('<div class="page page-half"><img/></div>').find('img').attr('src', pg.right.src).end());
          total += 2;
        } else {
          $flip.append($('<div class="page page-half"><img/></div>').find('img').attr('src', pg.src).end());
          total += 1;
        }
      });
      pageW0 = canonicalMobileW; pageH0 = canonicalMobileH;
    } else {
      // ESCRITORIO: spread como hoja (dos imágenes dentro); single como página normal
      spreads.forEach(pg=>{
        if (pg.type==='spread'){
          const $sheet = $('<div class="page sheet"></div>');
          $sheet.append($('<img/>').attr('src', pg.left.src));
          $sheet.append($('<img/>').attr('src', pg.right.src));
          $flip.append($sheet); total += 1;
        } else {
          $flip.append($('<div class="page"><img/></div>').find('img').attr('src', pg.src).end());
          total += 1;
        }
      });
      // marcar portada/contra duras (si existen como single)
      const $pages = $flip.children('.page');
      if ($pages.length>0)  $pages.first().addClass('hard');
      if ($pages.length>1)  $pages.last().addClass('hard');
      pageW0 = canonicalDesktopW; pageH0 = canonicalDesktopH;
    }

    // Inicializar Turn.js en SINGLE
    $flip.turn({
      width: pageW0, height: pageH0,
      autoCenter:true, elevation:50, gradients:true, acceleration:true,
      display:'single', page:1,
      when:{
        startup: ()=>{ $flip.turn('display','single'); applyLayout(true); },
        turning: ()=>{ $flip.turn('display','single'); applyLayout(true); },
        turned:  (e,page)=>{ $pageInfo.text(`${TITLE} — Página ${page} / ${total}`); $flip.turn('display','single'); applyLayout(true); }
      }
    });

    syncToolbarHeight(); applyLayout(true);
    setTimeout(()=>{ try{$flip.turn('page',1); $flip.turn('update');}catch{} },0);
  }

  async function ensurePdfExists(url){
    try{
      const r = await fetch(url, {method:'HEAD', cache:'no-store'});
      if (!r.ok) throw new Error('HTTP '+r.status);
    }catch(e){ throw new Error('No se encontró el PDF (404). Verifica la ruta: '+url); }
  }

  (async function init(){
    try{
      if (!PDF_URL){
        $loader.text("No se especificó el PDF (?doc=). Regresa al catálogo y abre de nuevo.");
        return;
      }
      await ensurePdfExists(PDF_URL);

      const pdf = await pdfjsLib.getDocument(PDF_URL).promise;
      $pageInfo.text(`Cargando ${TITLE}…`);
      $loader.text(`Cargando y renderizando ${pdf.numPages} páginas…`);

      spreads = [];

      for (let p=1; p<=pdf.numPages; p++){
        const isEdge = (p===1 || p===pdf.numPages);
        const scale  = isEdge ? SCALE_COVER : SCALE_INNER;

        const page = await pdf.getPage(p);
        const vp   = page.getViewport({ scale });
        const c    = document.createElement('canvas');
        c.width  = Math.ceil(vp.width);
        c.height = Math.ceil(vp.height);
        await page.render({ canvasContext:c.getContext('2d'), viewport:vp }).promise;

        const ratio = c.width / c.height;
        if (!isEdge && ratio > SPREAD_THRESHOLD){
          // interior ancho => spread
          const halves = splitCanvas(c);
          spreads.push({ type:'spread', left:halves.left, right:halves.right, w:c.width, h:c.height });
        } else {
          // portada/contra o interiores verticales => single
          spreads.push({ type:'single', src:c.toDataURL('image/jpeg',0.9), w:c.width, h:c.height });
        }
        await new Promise(r=>setTimeout(r,0));
      }

      // Fijar canónicos estables desde la primera interior si existe; si no, la primera
      const firstInterior = spreads.find(pg => pg.type==='spread') || spreads.find(pg => pg.type==='single') || spreads[0];
      if (firstInterior.type==='spread'){
        canonicalDesktopW = firstInterior.w;   canonicalDesktopH = firstInterior.h;   // hoja completa
        canonicalMobileW  = Math.floor(firstInterior.w/2); canonicalMobileH = firstInterior.h; // media hoja
      } else {
        canonicalDesktopW = firstInterior.w;   canonicalDesktopH = firstInterior.h;
        canonicalMobileW  = firstInterior.w;   canonicalMobileH  = firstInterior.h;
      }

      // Montar el flip (según móvil/escritorio) e inicializar
      mountFlip();

      $loader.addClass('hidden');
      bindUI();
      bindWheelPaging(); // ← activar scroll para pasar páginas

    }catch(err){
      console.error(err);
      $loader.text(err.message || "No se pudo cargar el PDF. Verifica la ruta y vuelve a intentar.");
      $pageInfo.text("Error al cargar el PDF");
    }
  })();
  </script>
</body>
</html>
